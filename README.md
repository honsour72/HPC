# Тестовое задание от GROUP-IB

## Задача
_Написать gRPC-сервис (не имеет значения, на чем писать),
который будет параллельно перебирать пароли к архиву по заданному словарю используя p7zip._

_Внутри очередь с приоритетом, запросы необходимо выполнять асинхронно.
Реализовать пример клиента (с блокировкой и без) - на Python 2.7._

## Решение
### Содержание решения
1. План решения
2. Структура репозитория проекта
3. Ход решения
4. Запуск решения
5. Замечания

### 1. План решения:
1. Необходимо запустить просейший пример кода по документации к grpc (https://grpc.io/docs/)
2. Настроить передачу паролей на сервер и написать простой код по анализу этих паролей и разархивации данных на сервере
3. Адаптировать п.2 под неблокирующий (асинхронный) метод работы
4. Преобразовать проект под python 2.7

### 2. Структура репозитория проекта
Структурно проект представлен 2 ветками для соответствующих версий python (py_3, py2_7)

В каждой находится 9 файлов:
- readme.md [описание проекта]
- requirements.txt [требуемые для работы зависимоти проекта]
- win.7z [тестовый архив с текстовым файлом, лежащий на сервере]
- client.py [интерфейс клиента]
- server.py [интерфейс сервера]
- async_client.py [интерфейс клиента асинхронный]
- async_server.py [интерфейс сервера асинхронный]
- data_pb2.py [дескриптор и форматы данных, согласно файлу .proto]
- data_pb2_grpc.py [вспомогательный модуль реализующий stub для передачи данных между клиентом и сервером]


### 3. Ход решения
1. После стандартной процедуры подготовки локальной директории проекта был запущен пример кода (https://grpc.io/docs/languages/python/quickstart/)
2. В процессе решения в репозитории проекта grpc (https://github.com/grpc/grpc/tree/v1.42.0/examples/python) был обнаружен пример, более подхоядщий: data_transmission. Он заключался в передаче на сервер сообщений разными способами: https://grpc.io/docs/languages/python/basics/#calling-service-methods. Среди которых наиболее подходящим оказался Request-streaming RPC. Он подразумевает собой передачу непрерывного "потока" в запросе на сервер (на более низком уровне - это генератор python)
3. Основываясь на последнем примере был написан код по распаковке архива с использованием модуля py7zr (zipfile для python 2.7) и вмонтирован в модуль сервера. На стороне клиента при промощи логики stream-unary* был реализован метод отправки паролей на сервер
4. Благодаря модулю aio библиотеки grpc была реализована неблокирующая (асинхронная) часть проекта
5. Заключительным этапом являлось преобразование кода в версию python 2.7 и оформление readme.md


### 4. Запуск решения
Для запуска решения нужно клонировать репозиторий:

        git clone https://github.com/honsour72/gRPC.git
        
Перейти в папку с репозиторием:

        cd gRPC
        
Запустить в терминале сначала сервер:

        python server.py
        
Затем в другом терминале запустить клиент:

        python client.py
        

> Примечание: При необходимости можно запустить асинхронный вариант async_server.py и async_client.py соответственно 


### 5. Замечания
* При анализе "распаковщиков" лучшим образом в плане быстродействия показал себя модуль py7zr, но, к сожалению, самые первые версии этого модуля, вышедшие аж 22 апреля 2019 года поддерживают python версии 3+ (https://pypi.org/project/py7zr/0.0.3/#:~:text=It%20uses%20a%20standard%20lzma%20module%20that%20is%20supported%20in%20Python3.3%20and%20later.). Таким образом при реализации проекта под версию языка python 2.7 был взят модуль zipfile 
* Нужно обратить внимание на то, что метод Stream-unary имеет небольшое превосходство над стандартной схемой unary-unary запроса. Это связано с тем, что сервер получает **НЕ** 1 запрос с одним паролем от клиента, а цепочку паролей в одном запросе-потоке (на более низком уровне - это генератор языка python). Если к такой реализации добавить ещё асинхронный метод, то можно добиться высоких показателей в скорости работы сервиса
* Важно отметить, что протокол gRPC не предусматривает передачу любых **файлов** (https://developers.google.com/protocol-buffers/docs/overview#scalar). При этом есть возможность передать байты информации (bytes). Основываясь на этом, я предположил, что архив можно закодировать, а затем уже отправить, но на этом способе будет сильно сказываться объём архива к закодированию     
* Уже в процессе написания readme понял, что можно было бы воспользоваться докер-контейнером для демонстрации совместной работы двух версий python, но всё же это - стрельба из пушки по воробьям 
